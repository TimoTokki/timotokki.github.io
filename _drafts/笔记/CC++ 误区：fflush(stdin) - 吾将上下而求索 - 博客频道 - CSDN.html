<html>
<head>
  <title>C/C++ 误区：fflush(stdin) - 吾将上下而求索 - 博客频道 - CSDN.NET</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/275193; Windows/6.3.9600;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="14402"/>
<h1>C/C++ 误区：fflush(stdin) - 吾将上下而求索 - 博客频道 - CSDN.NET</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2016/1/15 11:28</i></td></tr>
<tr><td><b>标签：</b></td><td><i>IT, 减藏</i></td></tr>
<tr><td><b>来源：</b></td><td><a href="http://blog.csdn.net/liuqiwen0512/article/details/7615981"><i>http://blog.csdn.net/liuqiwen0512/article/details/7615981</i></a></td></tr>
</table>
</div>
<br/>

<div><span><br/><div style="font-size: 16px"><div><div style="color:rgb(54, 46, 43);text-align:center;font-size:12px;font-family:Arial, Console, Verdana, 'Courier New';background:url(&quot;http://static.blog.csdn.net/skin/ink/css/../images/body_bg.jpg&quot;) 50% 0%;"><div style="background:url(&quot;http://static.blog.csdn.net/skin/ink/css/../images/head_bg.jpg&quot;) 50% 0% no-repeat;"><div style="text-align:left;"><div style="overflow:hidden;background:rgb(255, 255, 255);"><div><div><div style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:14px;line-height:26px;font-family:Arial;">

1. 为什么 fflush(stdin) 是错的？<br/>
首先请看以下程序：<br/>
<br/>
#include &lt;stdio.h&gt;<br/>
int main( void )<br/>
{<br/>
int i;<br/>
<br/>
for (;;)<br/>
   {<br/>
      fputs(&quot;Please input an integer: &quot;, stdout);<br/>
      scanf(&quot;%d&quot;, &amp;i);<br/>
      printf(&quot;%d\n&quot;, i);<br/>
}<br/>
<br/>
   return 0;<br/>
}<br/>
<br/>
这个程序首先会提示用户输入一个整数，然后等待用户输入，如果用户输入的是整数，<br/>
程序会输出刚才输入的整数，并且再次提示用户输入一个整数，然后等待用户 输入。<br/>
但是一旦用户输入的不是整数（如小数或者字母），假设 scanf 函数最后一次得到的整数是 2 ，<br/>
那么程序会不停地输出“Please input an integer: 2”。<br/>
这是因为 scanf(&quot;%d&quot;, &amp;i); 只能接受整数，如果用户输入了字母，则这个字母会遗留在“输入缓冲区”中。<br/>
因为缓冲中有数据，故而 scanf 函数不会等待用户输入，直接就去缓冲中读取，可是缓冲中的却是字母，<br/>
这个字母再次被遗留在缓冲中，如此反复，从而导致不停地输出“Please input an integer: 2”。<br/>
<br/>
也许有人会说：“居然这样，那么在 scanf 函数后面加上‘fflush(stdin);’，把输入缓冲清空掉不就行了？”<br/>
然而这是错的！<br/>
C和C++的标准里从来没有定义过 fflush(stdin)。<br/>
也许有人会说：“可是我用 fflush(stdin) 解决了这个<span>问题</span>，你怎么能说是错的呢？”<br/>
的确，某些<span>编译</span>器（如VC6）支持用 fflush(stdin) 来清空输入缓冲，<br/>
但是并非所有编译器都要支持这个功能（<span>linux</span> 下的 gcc 就不支持），<br/>
因为标准中根本没有定义 fflush(stdin)。<br/>
MSDN <span>文档</span>里 也清楚地写着<br/>
fflush on input stream is an extension to the C standard（fflush 操作输入流是对 C 标准的扩充）。<br/>
当然，如果你毫不在乎程序的移植性，用 fflush(stdin) 也没什么大问题。<br/>
以下是 C99 对 fflush 函数的定义：<br/>
<br/>
int fflush(FILE *stream);<br/>
如果 stream 指向输出流或者更新流（update stream），<br/>
并且这个更新流最近执行的操作不是输入，<br/>
那么 fflush 函数将把这个流中任何待写数据传送至宿主环境（host environment）写入<span>文件</span>。<br/>
否则，它的行为是未定义的。<br/>
<br/>
原文如下：<br/>
<br/>
int fflush(FILE *stream);<br/>
If stream points to an output stream or an update stream in which<br/>
the most recent operation was not input, the fflush function causes<br/>
any unwritten data for that stream to be delivered to the host environment<br/>
to be written to the file; otherwise, the behavior is undefined.<br/>
<br/>
其中，宿主环境可以理解为操作<span>系统</span>或内核等。<br/>
<br/>
由此可知，如果 stream 指向输入流（如 stdin），那么 fflush 函数的行为是不确定的。故而<span>使用</span> fflush(stdin)   是不正确的，至少是移植性不好的。<br/>
<br/>
2.    清空输入缓冲区的方法<br/>
虽然不可以用 fflush(stdin)，但是我们可以自己写代码来清空输入缓冲区。只需要在 scanf 函数后面加上几句简单的代码就可以了。<br/>
<br/>
       /* C 版本 */<br/>
       #include &lt;stdio.h&gt; <br/>
<br/>
<br/>
       int main( void )<br/>
       {<br/>
         int i, c;<br/>
             for ( ; ; )<br/>
         {<br/>
            fputs(&quot;Please input an integer: &quot;, stdout);<br/>
            scanf(&quot;%d&quot;, &amp;i);<br/>
<br/>
         if ( feof(stdin) || ferror(stdin) )<br/>
            { /* 如果用户输入文件结束标志（或文件已被读完）， */<br/>
               /* 或者发生读写错误，则退出循环             */<br/>
         <br/>
                   /* do something */<br/>
                   break;<br/>
            }<br/>
            /* 没有发生错误，清空输入流。                 */<br/>
            /* 通过 while 循环把输入流中的余留数据“吃”掉 */<br/>
            while ( (c = getchar()) != '\n' &amp;&amp; c != EOF ) ;<br/>
            /* 使用 scanf(&quot;%*[^\n]&quot;); 也可以清空输入流， */<br/>
<br/>
            /* 不过会残留 \n 字符。                          */<br/>
<br/>
            printf(&quot;%d\n&quot;, i);<br/>
         }<br/>
<br/>
         return 0;<br/>
       }<br/>
<br/>
<br/>
       /* C++ 版本 */<br/>
       #include &lt;iostream&gt;<br/>
       #include &lt;limits&gt; // 为了使用numeric_limits<br/>
<br/>
<br/>
    using std::cout;<br/>
       using std::endl;<br/>
       using std::cin;<br/>
       using std::numeric_limits;<br/>
       using std::streamsize;<br/>
<br/>
<br/>
    int main()<br/>
       {<br/>
         int value;<br/>
         for ( ; ; )<br/>
         {<br/>
            cout &lt;&lt; &quot;Enter an integer: &quot;;<br/>
            cin &gt;&gt; value;<br/>
            if ( cin.eof() || cin.bad() )<br/>
            { // 如果用户输入文件结束标志（或文件已被读完），<br/>
               // 或者发生读写错误，则退出循环<br/>
<br/>
                // do something<br/>
                   break;<br/>
            }<br/>
            // 读到非法字符后，输入流将处于出错状态，<br/>
            // 为了继续获取输入，首先要调用 clear 函数<br/>
            // 来清除输入流的错误标记，然后才能调用<br/>
            // ignore 函数来清除输入流中的数据。<br/>
            cin.clear();<br/>
            // numeric_limits&lt;streamsize&gt;::max() 返回输入缓冲的大小。<br/>
            // ignore 函数在此将把输入流中的数据清空。<br/>
            // 这两个函数的具体用法请读者自行查询。<br/>
            cin.ignore( numeric_limits&lt;streamsize&gt;::max(), '\n' );<br/>
<br/>
            cout &lt;&lt; value &lt;&lt; '\n';<br/>
         }<br/>
<br/>
      return 0;<br/>
       }<br/>
<br/>
参考资料：<br/>
<br/>
ISO/IEC 9899:1999 (E) Programming languages— C 7.19.5.2 The fflush function<br/>
<br/>
The C Programming Language 2nd Edition By Kernighan &amp; Ritchie<br/>
<br/>
ISO/IEC 14882(1998-9-01)Programming languages — C++<br/>
   
</div></div></div></div></div></div></div></div></div><br/></span>
</div></body></html> 