<html>
<head>
  <title>sprintf_百度百科</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/275193; Windows/6.3.9600;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="14149"/>
<h1>sprintf_百度百科</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2015/12/5 22:47</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2015/12/9 19:44</i></td></tr>
<tr><td><b>标签：</b></td><td><i>IT, 减藏</i></td></tr>
<tr><td><b>来源：</b></td><td><a href="http://baike.baidu.com/view/1295144.htm"><i>http://baike.baidu.com/view/1295144.htm</i></a></td></tr>
</table>
</div>
<br/>

<div>
<span style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><div><div><h1>sprintf</h1></div><a shape="rect" target="_blank">编辑</a> <a href="http://baike.baidu.com/view/10812319.htm" shape="rect" target="_blank" title="锁定">锁定</a><div>字符串格式化命令，主要功能是把格式化的数据写入某个字符串中。sprintf 是个 <a href="http://baike.baidu.com/view/552850.htm" shape="rect" target="_blank">变参</a>函数。</div><div><dl><dt>中文名</dt><dd>字符串格式输出</dd><dt>外文名</dt><dd>string print format</dd><dt>外语缩写</dt><dd>sprintf</dd></dl><dl><dt>主要功能</dt><dd>把格式化的数据写入某个字符串中</dd><dt>头文件</dt><dd><a href="http://baike.baidu.com/view/538727.htm" shape="rect" target="_blank">stdio.h</a></dd><dt>原    型</dt><dd>int sprintf</dd><dt>返回值</dt><dd>字符串长度</dd></dl></div><h2><a shape="rect" target="_blank">编辑</a></h2><div>把格式化的数据写入某个 <a href="http://baike.baidu.com/view/56072.htm" shape="rect" target="_blank">字符串</a> <a href="http://baike.baidu.com/view/266782.htm" shape="rect" target="_blank">缓冲区</a>。</div><div><a href="http://baike.baidu.com/view/538727.htm" shape="rect" target="_blank">stdio.h</a></div><div>int sprintf( char *buffer, const char *format, [ argument] … );</div><div><b><i>buffer</i></b>： <a href="http://baike.baidu.com/view/1006519.htm" shape="rect" target="_blank">char</a>型指针，指向将要写入的字符串的缓冲区。</div><div><i><b>format</b></i>：格式化字符串。</div><div><i><b>[argument]..</b></i> <b><i>.</i></b>：可选参数，可以是任何类型的数据。</div><div>返回值：字符串长度（ <a href="http://baike.baidu.com/subview/736226/5092486.htm" shape="rect" target="_blank">strlen</a>）</div><div><table><tbody><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1"><div><code>int</code>  <code>sprintf_s(</code> <code>char</code>  <code>*buffer,</code> <code>size_t</code>  <code>sizeOfBuffer,</code> <code>const</code>  <code>char</code>  <code>*format, [argument] ... );</code></div><div><code>int</code>  <code>_sprintf_s_l(</code> <code>char</code>  <code>*buffer,</code> <code>size_t</code>  <code>sizeOfBuffer,</code> <code>const</code>  <code>char</code>  <code>*format,locale_t locale ,[argument] ... );</code></div><div><code>int</code>  <code>swprintf_s(</code> <code>wchar_t</code>  <code>*buffer,</code> <code>size_t</code>  <code>sizeOfBuffer,</code> <code>const</code>  <code>wchar_t</code>  <code>*format ,[argument]...);</code></div><div><code>int</code>  <code>_swprintf_s_l(</code> <code>wchar_t</code>  <code>*buffer,</code> <code>size_t</code>  <code>sizeOfBuffer,</code> <code>const</code>  <code>wchar_t</code>  <code>*format,locale_t locale ,[argument]…);</code></div><div><code>template</code>  <code>&lt;</code> <code>size_t</code>  <code>size&gt;</code></div><div><code>int</code>  <code>sprintf_s(</code> <code>char</code>  <code>(&amp;buffer)[size],</code> <code>const</code>  <code>char</code>  <code>*format, [argument] ... ); </code> <code>//仅存在于C++</code></div><div><code>template</code>  <code>&lt;</code> <code>size_t</code>  <code>size&gt;</code></div><div><code>int</code>  <code>swprintf_s(</code> <code>wchar_t</code>  <code>(&amp;buffer)[size],</code> <code>const</code>  <code>wchar_t</code>  <code>*format ,[argument]...); </code> <code>//仅存在于C++</code></div></td></tr></tbody></table></div><h2>说明及应用 <a shape="rect" target="_blank">编辑</a></h2><div><table><tbody><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1"><div><code>/*例子*/</code></div></td></tr></tbody></table></div><div><table><tbody><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1"><div><code>#include&lt;stdio.h&gt;/*某个stdio.h*/</code></div><div><code>int</code> <code>　main()</code> <code>/*主函数“整数”类型*/</code></div><div><code>{</code></div><div><code>char</code> <code>　buffer[50];</code> <code>/*“字符”类型的数组，下面共有50个元素。*/</code></div><div><code>int</code> <code>　n,a=5,b=3;</code> <code>/*三个变量都为“整数”类型,int中间要有空格*/</code></div><div><code>n=</code> <code>sprintf</code> <code>(buffer,</code> <code>&quot;%d plus %d is %d&quot;</code> <code>,a,b,a+b);</code> <code>/*赋予数值*/</code></div><div><code>printf</code> <code>(</code> <code>&quot;[%s]is a string %d chars long\n&quot;</code> <code>,buffer,n);</code> <code>/*“格式输出函数”*/</code></div><div><code>return</code> <code>　0;</code> <code>/*“返回零”</code></div><div><code>也就是程序正常退出*/</code></div><div><code>}</code></div></td></tr></tbody></table></div><div>输出结果：</div><table><tbody><tr><td colspan="1" rowspan="1"><div>[5 plus 3 is 8] is a string 13 chars long</div></td></tr></tbody></table><div>sprintf格式的规格如下所示。[]中的部分是可选的。</div><div>%[指定参数][ <a href="http://baike.baidu.com/view/390932.htm" shape="rect" target="_blank">标识符</a>][宽度][.精度]指示符</div><div>若想输出'%'本身时, 请使用'%%'处理。</div><div>1. 处理字符方向。负号时表示从后向前处理。</div><div>2. 填空字元。 0 的话表示空格填 0；空格是内定值，表示空格就放着。</div><div>3. <a href="http://baike.baidu.com/view/263416.htm" shape="rect" target="_blank">字符</a>总宽度。为最小宽度。</div><div>4. 精确度。指在小数点后的浮点数位数。</div><div>%% 印出百分比符号，不转换。</div><div>%c 整数转成对应的 ASCII 字元。</div><div>%d 整数转成十进位。</div><div>%f 倍精确度数字转成浮点数。</div><div>%o 整数转成八进位。</div><div>%s 整数转成字符串。</div><div>%x 整数转成小写十六进位。</div><div>%X 整数转成大写十六进位。</div><div>$money = 123.1</div><div>$formatted = sprintf (&quot;%06.2f&quot;, $money); // 此时变数 $ formatted 值为 &quot;123.10&quot;</div><div>$formatted = sprintf (&quot;%08.2f&quot;, $money); // 此时变数 $ formatted 值为 &quot;00123.10&quot;</div><div>$formatted = sprintf (&quot;%-08.2f&quot;, $money); // 此时变数 $ formatted 值为 &quot;123.1000&quot;</div><div>$formatted = sprintf (&quot;%.2f%%&quot;, 0.95 * 100); // 格式化为百分比</div><div>%08.2f 解释:</div><div>0是 &quot;填空字元&quot; 表示,如果长度不足时就用0来填满。</div><div>8格式化后总长度</div><div>2f小数位长度，即2位</div><div>第3行值为&quot;00123.10&quot; 解释:</div><div>因为2f是(2位)+小数点符号(1位)+前面123(3位)=6位，总长度为8位,故前面用[填空字元]0表示，即00123.10</div><div>第4行值为&quot;123.1000&quot; 解释:</div><div><span style="background-color:rgb(255, 250, 165);-evernote-highlight:true;-evernote-highlighted:true;">-号为反向操作，然后填空字元0添加在最后面了</span></div><div>在将各种类型的数据构造成字符串时，sprintf 的强大功能很少会让你失望。由于sprintf 跟printf 在用法上几乎一样，只是打印的目的地不同而已，前者打印到字符串中，后者则直接在命令行上输出。这也导致sprintf 比printf 有用得多。</div><div>sprintf 是个 <a href="http://baike.baidu.com/view/552850.htm" shape="rect" target="_blank">变参</a>函数，定义如下：</div><div>int sprintf( char *buffer, const char *format [, argument] ... );</div><div>除了前两个参数类型固定外，后面可以接任意多个参数。而它的精华，显然就在第二个参数：</div><div>格式化字符串上。</div><div>printf 和sprintf 都使用格式化字符串来指定串的格式，在格式串内部使用一些以“%”开头的格式说明符（format specifications）来占据一个位置，在后边的 <a href="http://baike.baidu.com/view/552850.htm" shape="rect" target="_blank">变参</a>列表中提供相应的变量，最终函数就会用相应位置的变量来替代那个说明符，产生一个调用者想要的字符串。</div><h3>格式化数字字符串</h3><div>sprintf 最常见的应用之一莫过于把整数打印到字符串中，所以，sprintf 在大多数场合可以替代</div><div>itoa。</div><div>//把整数123 打印成一个字符串保存在s 中。</div><div>sprintf(s, &quot;%d&quot;, 123); //产生&quot;123&quot;</div><div>可以指定宽度，不足的左边补空格：</div><div>sprintf(s, &quot;%4d%4d&quot;, 123, 4567); //产生：&quot; 1234567&quot;</div><div>当然也可以左对齐：</div><div>sprintf(s, &quot;%-4d%4d&quot;, 123, 4567); //产生：&quot;123 4567&quot;</div><div>也可以按照16 进制打印：</div><div>sprintf(s, &quot;%8x&quot;, 4567); //小写16 进制，宽度占8 个位置， <a href="http://baike.baidu.com/view/1268354.htm" shape="rect" target="_blank">右对齐</a></div><div>sprintf(s, &quot;%-8X&quot;, 4568); //大写16 进制，宽度占8 个位置，左对齐</div><div>这样，一个整数的16 进制字符串就很容易得到，但我们在打印16 进制内容时， <span style="background-color:rgb(255, 250, 165);-evernote-highlight:true;-evernote-highlighted:true;">通常想要一种左边补0 的等宽格式，那该怎么做呢？很简单，在表示宽度的数字前面加个0 就可以了。</span></div><div><span style="background-color:rgb(255, 250, 165);-evernote-highlight:true;-evernote-highlighted:true;">sprintf(s, &quot;%08X&quot;, 4567); //产生：&quot;000011D7&quot;</span></div><div>上面以”%d”进行的10 进制打印同样也可以使用这种左边补0 的方式。</div><div>这里要注意一个符号扩展的问题：比如，假如我们想打印短整数（short）-1 的内存16 进制表示形式，在Win32 平台上，一个short 型占2 个 <a href="http://baike.baidu.com/view/60408.htm" shape="rect" target="_blank">字节</a>，所以我们自然希望用4 个16 进制数字来打印它：</div><div>short si = -1;</div><div>sprintf(s, &quot;%04X&quot;, si);</div><div>产生“FFFFFFFF”，怎么回事？因为sprintf 是个 <a href="http://baike.baidu.com/view/552850.htm" shape="rect" target="_blank">变参</a>函数，除了前面两个参数之外，后面的参数都不是 <a href="http://baike.baidu.com/view/1965709.htm" shape="rect" target="_blank">类型安全</a>的，函数更没有办法仅仅通过一个“%X”就能得知当初 <a href="http://baike.baidu.com/view/2369016.htm" shape="rect" target="_blank">函数调用</a>前参数压栈时被压进来的到底是个4 字节的整数还是个2 字节的短整数，所以采取了统一4 字节的处理方式，导致参数压栈时做了符号扩展，扩展成了32 位的整数-1，打印时4 个位置不够了，就把32 位整数-1 的8 位16 进制都打印出来了。</div><div>如果你想看si 的本来面目，那么就应该让 <a href="http://baike.baidu.com/view/487018.htm" shape="rect" target="_blank">编译器</a>做0 扩展而不是符号扩展（扩展时二进制左边补0 而不是补符号位）：</div><div>sprintf(s, &quot;%04X&quot;, (unsigned short)si);</div><div>就可以了。或者：</div><div>unsigned short si = -1;</div><div>sprintf(s, &quot;%04X&quot;, si);</div><div>sprintf 和printf 还可以按8 进制打印整数字符串，使用”%o”。注意8 进制和16 进制都不会打印出负数，都是无符号的，实际上也就是变量的内部编码的直接的16 进制或8 进制表示。</div><div>控制浮点数打印格式</div><div>浮点数的打印和格式控制是sprintf 的又一大常用功能，浮点数使用格式符”%f”控制，默认保留小数点后6 位数字，比如：</div><div>sprintf(s, &quot;%f&quot;, 3.1415926); //产生&quot;3.141593&quot;</div><div>但有时我们希望自己控制打印的宽度和小数位数，这时就应该使用：”%m.nf”格式，其中m 表示打印的宽度，n 表示小数点后的位数。比如：</div><div>sprintf(s, &quot;%10.3f&quot;, 3.1415626); //产生：&quot; 3.142&quot;</div><div>sprintf(s, &quot;%-10.3f&quot;, 3.1415626); //产生：&quot;3.142 &quot;</div><div>sprintf(s, &quot;%.3f&quot;, 3.1415626); //不指定总宽度，产生：&quot;3.142&quot;</div><div>注意一个问题，你猜</div><div>int i = 100;</div><div>sprintf(s, &quot;%.2f&quot;, i);</div><div>会打出什么东东来？“100.00”？对吗？自己试试就知道了，同时也试试下面这个：</div><div>sprintf(s, &quot;%.2f&quot;, (double)i);</div><div>第一个打出来的肯定不是正确结果，原因跟前面提到的一样，参数压栈时调用者并不知道跟i相对应的格式控制符是个”%f”。而函数执行时函数本身则并不知道当年被压入栈里的是个整数，于是可怜的保存整数i 的那4 个 <a href="http://baike.baidu.com/view/60408.htm" shape="rect" target="_blank">字节</a>就被不由分说地强行作为浮点数格式来解释了，整个乱套了。不过，如果有人有兴趣使用手工编码一个浮点数，那么倒可以使用这种方法来检验一下你手工编排的结果是否正确。</div><h3>字符/Ascii码</h3><div>我们知道，在C/C++语言中，char 也是一种普通的scalable 类型，除了 <a href="http://baike.baidu.com/view/731.htm" shape="rect" target="_blank">字长</a>之外，它与short，int，long 这些类型没有本质区别，只不过被大家习惯用来表示字符和字符串而已。（或许当年该把这个类型叫做“byte”，然后现在就可以根据实际情况，使用byte 或short 来把char 通过typedef 定义出来，这样更合适些）于是，使用”%d”或者”%x”打印一个字符，便能得出它的10 进制或16 进制的ASCII 码；反过来，使用”%c”打印一个整数，便可以看到它所对应的 <a href="http://baike.baidu.com/view/15482.htm" shape="rect" target="_blank">ASCII</a>字符。以下 <a href="http://baike.baidu.com/view/1005329.htm" shape="rect" target="_blank">程序段</a>把所有可见字符的ASCII 码对照表打印到屏幕上（这里采用printf，<span style="background-color:rgb(255, 250, 165);-evernote-highlight:true;">注意”#”与”%X”合用时自动为16 进制数增加”0X”前缀，为8进制数增加“0”前缀</span><br/>
）：</div><div>for(int i = 32; i &lt; 127; i++) {</div><div>printf(&quot;[ %c ]: %3d 0x%#04X\n&quot;, i, i, i);</div><div>连接字符串</div><div>sprintf 的格式控制串中既然可以插入各种东西，并最终把它们“连成一串”，自然也就能够连接字符串，从而在许多场合可以替代strcat，但sprintf 能够一次连接多个字符串（自然也可以同时在它们中间插入别的内容，总之非常灵活）。比如：</div><div><table><tbody><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1"><div><code>char</code> <code>*buf[60];</code></div><div><code>char</code> <code>*who=</code> <code>&quot;I&quot;</code> <code>;</code></div><div><code>char</code> <code>*whom=</code> <code>&quot;CSDN&quot;</code> <code>;</code></div><div><code>sprintf</code> <code>(buf,</code> <code>&quot;%slove%s.&quot;</code> <code>,who,whom);</code></div><div><code>printf</code> <code>(</code> <code>&quot;%s&quot;</code> <code>,buf);</code></div><div><code>//输出结果：&quot;IloveCSDN.&quot;</code></div></td></tr></tbody></table></div><div>strcat 只能连接字符串（一段以'\0'结尾的字符 <a href="http://baike.baidu.com/view/209670.htm" shape="rect" target="_blank">数组</a>或叫做字符缓冲，null-terminated-string），但有时我们有两段字符 <a href="http://baike.baidu.com/view/266782.htm" shape="rect" target="_blank">缓冲区</a>，他们并不是以 ’’结尾。比如许多从第三方 <a href="http://baike.baidu.com/view/905012.htm" shape="rect" target="_blank">库函数</a>中返回的字符数组，从硬件或者网络传输中读进来的字符流，它们未必每一段字符序列后面都有个相应的’’来结尾。如果直接连接，不管是sprintf 还是strcat 肯定会导致非法内存操作，而strncat 也至少要求第一个参数是个null-terminated-string，那该怎么办呢？我们自然会想起前面介绍打印整数和浮点数时可以指定宽度，字符串也一样的。比如：</div><div>char a1[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G'};</div><div>char a2[] = {'H', 'I', 'J', 'K', 'L', 'M', 'N'};</div><div>sprintf(s, &quot;%s%s&quot;, a1, a2); //Don't do that!</div><div>十有八九要出问题了。是否可以改成：</div><div>sprintf(s, &quot;%7s%7s&quot;, a1, a2);</div><div>也没好到哪儿去，正确的应该是：</div><div>sprintf(s, &quot;%.7s%.7s&quot;, a1, a2);//产生：&quot;ABCDEFGHIJKLMN&quot;</div><div>这可以类比打印浮点数的”%m/nf”，在”%m.ns”中，m 表示占用宽度（ <a href="http://baike.baidu.com/view/263416.htm" shape="rect" target="_blank">字符</a>串长度不足时补空格，超出了则按照实际宽度打印），n 才表示从相应的字符串中最多取用的字符数。通常在打印字符串时m 没什么大用，还是点号后面的n 用的多。自然，也可以前后都只取部分字符：</div><div>sprintf(s, &quot;%.6s%.5s&quot;, a1, a2);//产生：&quot;ABCDEFHIJKL&quot;</div><div>在许多时候，我们或许还希望这些格式控制符中用以指定长度信息的数字是动态的，而不是静态指定的，因为许多时候，程序要到运行时才会清楚到底需要取字符 <a href="http://baike.baidu.com/view/209670.htm" shape="rect" target="_blank">数组</a>中的几个字符，这种动态的宽度/精度设置功能在sprintf 的实现中也被考虑到了，sprintf 采用”*”来占用一个本来需要一个指定宽度或精度的常数数字的位置，同样，而实际的宽度或精度就可以和其它被打印的变量一样被提供出来，于是，上面的例子可以变成：</div><div>sprintf(s, &quot;%.*s%.*s&quot;, 7, a1, 7, a2);</div><div>sprintf(s, &quot;%.*s%.*s&quot;, sizeof(a1), a1, sizeof(a2), a2);</div><div>实际上，前面介绍的打印 <a href="http://baike.baidu.com/view/263416.htm" shape="rect" target="_blank">字符</a>、整数、浮点数等都可以动态指定那些 <a href="http://baike.baidu.com/view/346799.htm" shape="rect" target="_blank">常量</a>值，比如：</div><div><table><tbody><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1"><div><code>sprintf</code> <code>(s,</code> <code>&quot;%-*d&quot;</code> <code>,4,</code> <code>'A'</code> <code>);</code> <code>//产生&quot;65&quot;</code></div><div><code>sprintf</code> <code>(s,</code> <code>&quot;%#0*X&quot;</code> <code>,8,128);</code> <code>//产生&quot;0X000080&quot;，&quot;#&quot;产生0X</code></div><div><code>sprintf</code> <code>(s,</code> <code>&quot;%*.*f&quot;</code> <code>,10,2,3.1415926);</code> <code>//产生&quot;3.14&quot;</code></div></td></tr></tbody></table></div><div>打印地址信息</div><div>有时 <a href="http://baike.baidu.com/view/499639.htm" shape="rect" target="_blank">调试程序</a>时，我们可能想查看某些变量或者成员的地址，由于地址或者 <a href="http://baike.baidu.com/view/159417.htm" shape="rect" target="_blank">指针</a>也不过是个32 位的数，你完全可以使用打印 <a href="http://baike.baidu.com/view/6052699.htm" shape="rect" target="_blank">无符号整数</a>的”%u”把他们打印出来：</div><div><table><tbody><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1"><div><code>sprintf</code> <code>(s,</code> <code>&quot;%u&quot;</code> <code>,&amp;i);</code></div></td></tr></tbody></table></div><div>不过通常人们还是喜欢使用16 进制而不是10 进制来显示一个地址：</div><div><table><tbody><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1"><div><code>sprintf</code> <code>(s,</code> <code>&quot;%08X&quot;</code> <code>,&amp;i);</code></div></td></tr></tbody></table></div><div>然而，这些都是间接的方法，对于地址打印，sprintf 提供了专门的”%p”：</div><div><table><tbody><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1"><div><code>sprintf</code> <code>(s,</code> <code>&quot;%p&quot;</code> <code>,&amp;i);</code></div></td></tr></tbody></table></div><div>我觉得它实际上就相当于：</div><div><table><tbody><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1"><div><code>sprintf</code> <code>(s,</code> <code>&quot;%0*x&quot;</code> <code>,2*</code> <code>sizeof</code> <code>(</code> <code>void</code> <code>*),&amp;i);</code></div></td></tr></tbody></table></div><div>利用sprintf 的返回值</div><div>较少有人注意printf/sprintf 函数的返回值，但有时它却是有用的，sprintf 返回了本次 <a href="http://baike.baidu.com/view/2369016.htm" shape="rect" target="_blank">函数调用</a>最终打印到字符 <a href="http://baike.baidu.com/view/266782.htm" shape="rect" target="_blank">缓冲区</a>中的字符数目。也就是说每当一次sprinf 调用结束以后，你无须再调用一次strlen 便已经知道了结果字符串的长度。如：</div><div><table><tbody><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1"><div><code>intlen=</code> <code>sprintf</code> <code>(s,</code> <code>&quot;%d&quot;</code> <code>,i);</code></div></td></tr></tbody></table></div><div>对于正整数来说，len 便等于整数i 的10 进制位数。</div><div>下面的是个完整的例子，产生10 个[0, 100)之间的随机数，并将他们打印到一个字符 <a href="http://baike.baidu.com/view/209670.htm" shape="rect" target="_blank">数组</a>s 中，</div><div>以逗号分隔开。</div><div><table><tbody><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1"><div><code>#include&lt;stdio.h&gt;</code></div><div><code>#include&lt;stdlib.h&gt;</code></div><div><code>#include&lt;time.h&gt;</code></div><div><code>intmain()</code></div><div><code>{</code></div><div><code>srand</code> <code>(</code> <code>time</code> <code>(0));</code></div><div><code>chars[64];</code></div><div><code>intoffset=0;</code></div><div><code>for</code> <code>(inti=0;i&lt;10;i++)</code></div><div><code>{</code></div><div><code>offset+=</code> <code>sprintf</code> <code>(s+offset,</code> <code>&quot;%d,&quot;</code> <code>,</code> <code>rand</code> <code>()%100);</code></div><div><code>}</code></div><div><code>s[offset-1]=</code> <code>'\n'</code> <code>;</code> <code>//将最后一个逗号换成换行符。</code></div><div><code>printf</code> <code>(s);</code></div><div><code>return0;</code></div><div><code>}</code></div></td></tr></tbody></table></div><div>设想当你从数据库中取出一条记录，然后希望把他们的各个字段按照某种规则连接成一个字符串时，就可以使用这种方法，从理论上讲，他应该比不断的strcat 效率高，因为strcat 每次调用都需要先找到最后的那个’’的位置，而在上面给出的例子中，我们每次都利用sprintf 返回值把这个位置直接记下来了。</div><div>MSDN中例子：</div><div>//crt_sprintf.c//compilewith:/W3//Thisprogramusessprintftoformatvarious//dataandplacetheminthestringnamedbuffer.</div><div><table><tbody><tr><td colspan="1" rowspan="1"></td><td colspan="1" rowspan="1"><div><code>#include&lt;stdio.h&gt;</code></div><div><code>intmain(</code> <code>void</code> <code>)</code></div><div><code>{</code></div><div><code>charbuffer[200],s[]=</code> <code>&quot;computer&quot;</code> <code>,c=</code> <code>'l'</code> <code>;</code></div><div><code>inti=35,j;</code></div><div><code>floatfp=1.7320534f;</code> <code>//Formatandprintvariousdata:</code></div><div><code>j=</code> <code>sprintf</code> <code>(buffer,</code> <code>&quot;String:%s\n&quot;</code> <code>,s);</code> <code>//C4996</code></div><div><code>j+=</code> <code>sprintf</code> <code>(buffer+j,</code> <code>&quot;Character:%c\n&quot;</code> <code>,c);</code> <code>//C4996</code></div><div><code>j+=</code> <code>sprintf</code> <code>(buffer+j,</code> <code>&quot;Integer:%d\n&quot;</code> <code>,i);</code> <code>//C4996</code></div><div><code>j+=</code> <code>sprintf</code> <code>(buffer+j,</code> <code>&quot;Real:%f\n&quot;</code> <code>,fp);</code> <code>//C4996</code></div><div><code>//Note:sprintfisdeprecated;considerusingsprintf_sinstead</code></div><div><code>printf</code> <code>(</code> <code>&quot;Output:\n%s\ncharactercount=%d\n&quot;</code> <code>,buffer,j);</code></div><div><code>}</code></div><div><code>Copy</code></div><div><code>Output:</code></div><div><code>String:computer</code></div><div><code>Character:l</code></div><div><code>Integer:35</code></div><div><code>Real:1.732053</code></div><div><code>charactercount=53</code></div></td></tr></tbody></table></div><h2><a shape="rect" target="_blank">编辑</a></h2><div>sprintf 是个 <a href="http://baike.baidu.com/view/552850.htm" shape="rect" target="_blank">变参</a>函数，使用时经常出问题，而且只要出问题通常就是能导致程序崩溃的内存访问错误，但好在由sprintf 误用导致的问题虽然严重，却很容易找出，无非就是那么几种情况，通常用眼睛再把出错的代码多看几眼就看出来了。</div><div><a href="http://baike.baidu.com/view/36638.htm" shape="rect" target="_blank"><b>缓冲区溢出</b></a></div><div>第一个参数的长度太短了，没的说，给个大点的地方吧。当然也可能是后面的参数的问题，建议变参对应一定要细心，而打印 <a href="http://baike.baidu.com/view/263416.htm" shape="rect" target="_blank">字符</a>串时，尽量使用”%.ns”的形式指定最大字符数。</div><div><b>忘记了第一个参数</b></div><div>低级得不能再低级问题，用printf 用得太惯了。//偶就常犯。：。（</div><div><b>变参对应出问题</b></div><div>通常是忘记了提供对应某个格式符的 <a href="http://baike.baidu.com/view/552850.htm" shape="rect" target="_blank">变参</a>，导致以后的参数统统错位，检查检查吧。尤其是对应”*”的那些参数，都提供了吗？不要把一个整数对应一个”%s”， <a href="http://baike.baidu.com/view/487018.htm" shape="rect" target="_blank">编译器</a>会觉得你欺她太甚了（编译器是obj 和exe 的妈妈，应该是个女的，:P）。</div><div><b>sprintf_s和snprintf</b></div><div><a href="http://baike.baidu.com/view/2666640.htm" shape="rect" target="_blank">sprintf_s</a>()是sprintf()的安全版本，通过指定 <a href="http://baike.baidu.com/view/266782.htm" shape="rect" target="_blank">缓冲区</a>长度来避免sprintf()存在的溢出风险 。在使用VS2008时如果你使用了sprintf函数，那么编译器会发出警告：使用sprintf存在风险，建议使用sprintf_s。这个安全版本的原型是：</div><div>int sprintf_s(char *buffer,size_t sizeOfBuffer,const char *format [,argument] ... );</div><div>不过sprintf_s()是微软私有的函数，考虑到跨平台移植，最好使用snprintf()。两者的原型基本相同：</div><div>int _snprintf(char *buffer, size_t count, const char *format [,argument] ... );</div><div><b>strftime</b></div><div>spritf 还有个不错的表妹：strftime，专门用于格式化时间字符串的，用法跟她表哥很像，也是一大堆格式控制符，只是毕竟小姑娘家心细，她还要调用者指定 <a href="http://baike.baidu.com/view/266782.htm" shape="rect" target="_blank">缓冲区</a>的最大长度，可能是为了在出现问题时可以推卸责任吧。这里举个例子：</div><div>time_t t = time(0);</div><div>//产生&quot;YYYY-MM-DD hh:mm:ss&quot;格式的字符串。</div><div>char s[32];</div><div>strftime(s, sizeof(s), &quot;%Y-%m-%d %H:%M:%S&quot;, localtime(&amp;t));</div><div>sprintf 在MFC 中也能找到他的知音：CString::Format，strftime 在MFC 中自然也有她的同道：CTime::Format，这一对由于从 <a href="http://baike.baidu.com/view/125370.htm" shape="rect" target="_blank">面向对象</a>那里得到了赞助，用以写出的代码更觉优雅。</div></div></span>
</div></body></html> 